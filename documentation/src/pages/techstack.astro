---
layout: '../layouts/Layout.astro'
title: 'Tech Stack'
description: 'The tools and platforms we chose for our project and why they work for us.'
---

<section class="not-prose mb-6 px-6 max-w-4xl mx-auto">
  <h1 class="text-3xl font-bold tracking-tight">Our Tech Stack</h1>
  <p class="mt-2 text-slate-600 dark:text-slate-300">
    We are building a full stack web app with a React frontend, a Spring Boot backend on Render, a PostgreSQL database, and OAuth2 login handled by Spring Security.
    Below we explain why we chose each tool and how they fit together.
  </p>
</section>

<div class="prose prose-slate dark:prose-invert px-6 max-w-4xl mx-auto">

  <h2>Frontend: React</h2>
  <p>
    We chose React because it is flexible, well documented, and supported by a large community. React components help us reuse UI pieces and keep screens consistent.
    To keep things simple, we use local state where possible and small, focused components.
  </p>

  <h2>Backend: Spring Boot on Render</h2>
  <p>
    Spring Boot makes it straightforward to build a clean REST API in Java. We secure endpoints with Spring Security and its OAuth2 support.
    We deploy the backend on Render so we do not manage servers by hand. Render gives us quick deployments, logs, and simple scaling.
  </p>

    <h2>Database: Supabase (PostgreSQL-backed)</h2>
  <p>
    We use <strong>Supabase</strong> as our hosted database platform because it provides a fully-managed
    PostgreSQL instance with built-in authentication, row-level security, and real-time capabilities.
    Supabase offers the flexibility of SQL with the convenience of an API layer and an integrated dashboard
    for easy data management. This setup lets us focus on building features rather than maintaining servers.
    Schema changes and migrations remain version-controlled and transparent, while Supabase's scalability
    ensures smooth performance as our dataset grows.
  </p>

  <h2>Authentication: Firebase Authentication</h2>
  <p>
    User authentication is handled through <strong>Firebase Authentication</strong>, allowing secure sign-in
    via email/password, Google, or other OAuth providers. Firebase simplifies the entire login flow and token
    lifecycle management, removing the need to handle session storage or refresh tokens manually.
    The frontend interacts directly with Firebase's SDK to authenticate users and receive verified ID tokens,
    which are then validated by our backend for protected API routes.
  </p>
  <ul>
    <li>Users log in through Firebase's secure, hosted authentication flow.</li>
    <li>Firebase issues a short-lived ID token to the client.</li>
    <li>The frontend includes this token in API requests to authorize access.</li>
    <li>The backend verifies the token and enforces role-based permissions for endpoints.</li>
  </ul>


  <h2>How everything fits together</h2>

  <!-- Responsive, accessible SVG diagram (Supabase + Firebase Auth) -->
<div class="not-prose mt-4 mb-8 rounded-xl border border-slate-200 bg-white/80 p-6 dark:border-slate-800 dark:bg-slate-900/60">
  <svg viewBox="0 0 1080 480" role="img" aria-label="System diagram: React client, Spring Boot API on Render, Supabase database, and Firebase Authentication">
    <defs>
      <marker id="arrow" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
        <path d="M 0 0 L 10 5 L 0 10 z" fill="currentColor"></path>
      </marker>
      <style>
        .box { fill: white; stroke: #9bb894ff; stroke-width: 2; rx: 10; }
        .label { font: 15px system-ui, -apple-system, Segoe UI, Roboto, Arial; fill: #0f172a; }
        .title { font-weight: 700; }
        .note  { font: 13px system-ui, -apple-system, Segoe UI, Roboto, Arial; fill: #006c76ff; opacity: 0.85; }
        @media (prefers-color-scheme: dark) {
          .box { fill: rgba(15,23,42,0.9); stroke: #ffffff; }
          .label { fill: #ffffff; }
        }
      </style>
    </defs>

    <!-- React Client -->
    <rect x="40" y="80" width="280" height="110" class="box"></rect>
    <text x="60" y="115" class="label title">React (Frontend)</text>
    <text x="60" y="140" class="label">SPA, calls API, shows UI</text>

    <!-- Spring Boot API -->
    <rect x="370" y="80" width="280" height="110" class="box"></rect>
    <text x="390" y="115" class="label title">Spring Boot API</text>
    <text x="390" y="140" class="label">REST endpoints, Auth validation</text>

    <!-- Render -->
    <rect x="370" y="220" width="280" height="70" class="box"></rect>
    <text x="390" y="260" class="label">Hosted on Render</text>

    <!-- Supabase -->
    <rect x="700" y="80" width="300" height="110" class="box"></rect>
    <text x="720" y="115" class="label title">Supabase (PostgreSQL)</text>
    <text x="720" y="140" class="label">Relational data, API, real-time</text>

    <!-- Firebase Auth -->
    <rect x="40" y="250" width="280" height="110" class="box"></rect>
    <text x="60" y="285" class="label title">Firebase Authentication</text>
    <text x="60" y="310" class="label">Google, Email/Password, etc.</text>

    <!-- Arrows and flow notes -->

    <!-- React -> API normal calls -->
    <line x1="320" y1="125" x2="370" y2="125" stroke="currentColor" stroke-width="2" marker-end="url(#arrow)"></line>
    <text x="330" y="115" class="note">HTTPS JSON</text>

    <!-- API -> DB -->
    <line x1="650" y1="125" x2="700" y2="125" stroke="currentColor" stroke-width="2" marker-end="url(#arrow)"></line>
    <text x="655" y="115" class="note">SQL / REST</text>

    <!-- Login: React -> Firebase -->
    <line x1="180" y1="190" x2="180" y2="250" stroke="currentColor" stroke-width="2" marker-end="url(#arrow)"></line>
    <text x="70" y="215" class="note">User signs in via Firebase</text>

    <!-- Firebase -> React -->
    <line x1="180" y1="360" x2="180" y2="310" stroke="currentColor" stroke-width="2" marker-end="url(#arrow)"></line>
    <text x="80" y="345" class="note">Returns ID token</text>

    <!-- React -> API with token -->
    <line x1="320" y1="145" x2="370" y2="145" stroke="currentColor" stroke-width="2" marker-end="url(#arrow)"></line>
    <text x="230" y="155" class="note">Bearer token in header</text>

    <!-- API verifies token -->
    <line x1="370" y1="190" x2="370" y2="220" stroke="currentColor" stroke-width="2" marker-end="url(#arrow)"></line>
    <text x="380" y="205" class="note">CI/CD deploy</text>

    <!-- Normal authenticated flow -->
    <line x1="650" y1="145" x2="700" y2="145" stroke="currentColor" stroke-width="2" marker-end="url(#arrow)"></line>
    <text x="655" y="165" class="note">Authorized queries</text>
  </svg>
</div>


  <h3>In short</h3>
  <p>
    React renders the UI and calls the API. For login, it sends the user to the backend's OAuth2 login route.
    Spring Security redirects to the OAuth2 provider, handles the callback, and creates a secure session.
    Authenticated API requests include the session cookie automatically. The API, hosted on Render, reads and writes data in PostgreSQL.
  </p>

  <h2>Why this works for us</h2>
  <p>
    This keeps secrets and token handling on the server, reduces client complexity, and lets Spring Security enforce policies.
    React gives us a smooth UI, Spring Boot provides a solid and secure API, PostgreSQL is dependable for our data, and Render makes deployments simple.
    If our needs change, each part can scale or be swapped without rewriting the whole system.
  </p>

</div>
